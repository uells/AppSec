## CSP (Content Security Policy)
[**CSP (Content Security Policy)**](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html) — это набор правил, которые браузер применяет к странице: **какие источники скриптов/стилей/картинок разрешены**, можно ли выполнять inline-код, можно ли делать `eval`, куда можно отправлять формы, кто может встраивать страницу во фрейм и т.д. Главная практическая цель — **сильно усложнить XSS** (и часть связанных атак), даже если где-то в коде всё-таки появилась уязвимость.

### Панацея от XSS?
`CSP` — это второй уровень защиты, который особенно помогает против XSS: она не устраняет уязвимости, но сильно усложняет их эксплуатацию. Даже на статическом сайте `CSP` (вместе с SRI) снижает риск подмены сторонних скриптов, если внешний источник будет скомпрометирован. При этом `CSP` **не заменяет правильную защиту от XSS** (экранирование, валидацию и т.д.), а **используется поверх неё как дополнительный слой**.

### Как использовать?
- `Content-Security-Policy` - использование этого заголовка является предпочтительным способом и поддерживает весь набор функций CSP. Отправляйте его во всех HTTP-ответах, а не только на главную страницу.
- `Content-Security-Policy-Report-Only Header` - это режим CSP, который не блокирует нарушающие ресурсы/скрипты, а только логирует и отправляет отчёты о нарушениях. Используется, чтобы обкатать и настроить CSP на реальном сайте перед включением блокирующего `Content-Security-Policy`
- Метатег `<meta http-equiv="Content-Security-Policy" ...>` используют, когда нельзя выставить CSP через HTTP-заголовки (например, при раздаче HTML с CDN). Он всё ещё может дать полноценные ограничения загрузки/исполнения ресурсов (в т.ч. защиту от XSS), но **не поддерживает часть возможностей**, например `frame-ancestors`, `sandbox` и отправку отчётов о нарушениях (`report-to`/`report-uri`).

Для того чтобы включить CSP, необходимо настроить сервер так, чтобы в ответах он использовал HTTP-заголовок Content-Security-Policy
В качестве альтернативы настройке сервера, вы можете сконфигурировать CSP с помощью элемента <meta>. Например, так: `<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">`

### Зачем это нужно?
Если у тебя есть уязвимость (XSS), без CSP злоумышленник может:
* выполнить произвольный JS в браузере жертвы,
* украсть токены/данные, делать запросы от имени пользователя,
* подменять интерфейс, перенаправлять и т.п.

CSP позволяет сказать браузеру:
* “скрипты только с моего домена”,
* “inline-скрипты запрещены”,
* “разрешать скрипты только с nonce/хэшем”,
* “никаких `eval`”,
* “страницу нельзя встраивать во фреймы” (против clickjacking) и т.д.

### Директивы
* **`default-src`** — “политика по умолчанию” для всех типов ресурсов, если для них не задано отдельное правило. Удобно ставить базовый минимум (например, только `'self'`).

* **`script-src`** — откуда можно загружать и выполнять JavaScript, включая запрет inline-скриптов и `eval`. Это ключевая директива для защиты от XSS (nonce/хэши задаются здесь).

* **`style-src`** — источники CSS и разрешение/запрет inline-стилей. Часто требует аккуратной настройки, если есть inline `<style>` или `style=""`.

* **`img-src`** — источники изображений (включая `data:` при необходимости). Ограничивает подгрузку картинок с чужих доменов.

* **`connect-src`** — куда страница может делать сетевые запросы (fetch/XHR/WebSocket/EventSource). Важна для SPA и API, ограничивает “утечку” данных через запросы на чужие домены.

* **`font-src`** — источники шрифтов. Нужна, если шрифты не только локальные.
* **`frame-src`** - указывает допустимые источники для вложенных контекстов просмотра, загружаемых в такие элементы, как `<frame>` и `<iframe>`.

* **`object-src`** — источники для `<object>/<embed>/<applet>`; обычно ставят `'none'`, чтобы закрыть старые векторы атак через плагины.

* **`base-uri`** — ограничивает, можно ли менять `<base href>`, что влияет на все относительные URL. Защищает от подмены базового URL злоумышленником.

* **`form-action`** — куда разрешено отправлять формы (`<form action=...>`). Помогает предотвращать “утечки” через подмену адреса отправки.

* **`frame-ancestors`** — кто может встраивать твою страницу во фрейм (`iframe`). Основная защита от clickjacking (аналог/замена `X-Frame-Options`).

Про остальные директивы можно почтать на сайте [cheatsheetseries.owasp.org](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html#fetch-directives).

### Значения директив
#### Базовые “источники” (source expressions)
- **`'self'`** — разрешить только текущий origin (протокол+домен+порт).
- **`'none'`** — полностью запретить (ничего не грузить/не исполнять).
- **`<scheme>:`** — разрешить по схеме: `https:`, `wss:`, `data:`, `blob:`  
  *(например `https:` = любой HTTPS-источник; `data:`/`blob:` — спец-URL, включать только при необходимости).*
- **`<host>`** — разрешить конкретный источник: `https://cdn.example.com` *(предпочтительно)*.
- **`*.example.com`** — разрешить поддомены *(осторожно: расширяет поверхность)*.
- **`'nonce-<base64>'`** — разрешить только теги `<script>/<style>` с совпадающим `nonce`.
- **`'sha256-<base64>'` / `'sha384-…'` / `'sha512-…'`** — разрешить конкретный inline-код по хэшу.
- **`'strict-dynamic'`** — если скрипт с nonce/хэшем запустился, его динамические подгрузки скриптов тоже считаются разрешёнными.
- **`'unsafe-inline'`** — разрешить любой inline JS/CSS *(ослабляет, нежелательно)*.
- **`'unsafe-eval'`** — разрешить `eval/new Function` *(ослабляет, нежелательно)*.
- **`'unsafe-hashes'`** — разрешать inline-обработчики (`onclick` и т.п.) по хэшам *(редко, осознанно)*.
- **`'report-sample'`** — добавлять фрагмент нарушающего кода в отчёты (удобно для дебага).
- **`'wasm-unsafe-eval'`** — разрешить отдельные сценарии выполнения WebAssembly, связанные с eval *(редко нужно)*.

#### Директивы-флаги (без значений)
- **`upgrade-insecure-requests`** — автоматически пытаться заменить `http://` на `https://`.
- **`block-all-mixed-content`** — запретить смешанный контент (http-ресурсы на https-странице).

### Примеры политик
**Простой сайт без CDN и без inline-скриптов**
```http
Content-Security-Policy: default-src 'self'; base-uri 'self'; object-src 'none'; frame-ancestors 'none'
```
**То же, но с картинками data: (base64) и запросами к API**
```http
Content-Security-Policy: default-src 'self'; img-src 'self' data:; connect-src 'self' https://api.example.com; base-uri 'self'; object-src 'none'; frame-ancestors 'none'
```
**С внешними шрифтами Google Fonts**
```http
Content-Security-Policy: default-src 'self'; style-src 'self' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; object-src 'none'; base-uri 'self'
```
**Разрешить встраивание страницы только на своём домене и у партнёра**
```http
Content-Security-Policy: frame-ancestors 'self' https://partner.example.com
```
**Если стили частично inline — через nonce/хеш**
```http
Content-Security-Policy: default-src 'self'; style-src 'self' 'nonce-<RANDOM>'; script-src 'self' 'nonce-<RANDOM>'; object-src 'none'; base-uri 'self'
```

**SPA/бандлер + строгий режим через nonce**.
В контексте CSP “строгий режим” обычно означает, что ты не доверяешь списку доменов, а разрешаешь выполнение скриптов только по nonce/хэшу, и запрещаешь всё остальное.
```http
Content-Security-Policy: default-src 'self'; base-uri 'self'; object-src 'none'; frame-ancestors 'none'; script-src 'nonce-<RANDOM>' 'strict-dynamic' 'self'; style-src 'self'
```

### Что означает `script-src 'nonce-<RANDOM>' 'strict-dynamic' 'self'`
Эти значения стоят вместе, чтобы:
- в новых браузерах работал строгий режим nonce + strict-dynamic,
- в старых был fallback хотя бы на 'self', чтобы сайт не развалился.

В старых/частично поддерживающих браузерах без fallback `self` скрипты не будут выполняться вообще, даже если он поддерживает `nonce`, но у тебя есть скрипты без `nonce` (например, `<script src="/app.js"></script>`) - они будут заблокированы.

### Про хеш и nonce и немного про `strict dynamic`

* **Nonce**: сервер генерирует случайный одноразовый токен на каждый ответ, добавляет его в CSP (`script-src 'nonce-…'`) и в нужные теги `<script nonce="…">` / `<style nonce="…">`. Браузер выполняет только те inline/скрипты, у которых nonce совпал.
* **Hash**: считаешь `sha256/384/512` от точного содержимого inline `<script>`/`<style>`, добавляешь хэш в CSP (`script-src 'sha256-…'`). Браузер выполнит только тот inline-код, чей хэш совпадает.

`Nonce` можно ставить и на inline `<script>...</script>`, и на внешние `<script src="...">`.
А вот хэши в `CSP` применяются в основном к inline-коду (потому что хэш считается от содержимого).

Если поставить `nonce` на внешний `<script src="...">` и включить `strict-dynamic`, браузер выполнит этот скрипт как “доверенный”. Затем все скрипты, которые он подключит динамически, тоже будут разрешены, даже без перечисления доменов в CSP. Скрипты без nonce (вставленные напрямую или через XSS) будут блокироваться.
```http
Content-Security-Policy: script-src 'nonce-r4Nd0mBase64Token' 'strict-dynamic'
```

В CSP с `strict-dynamic` скрипты без `nonce` (даже с `'self'`) в современных браузерах **блокируются**. В старых браузерах без поддержки `strict-dynamic` действует fallback `'self'`, поэтому скрипт **запустится**.

```htpp
Content-Security-Policy: script-src 'nonce-r4Nd0mBase64Token' 'strict-dynamic' 'self'
```

```html
<!-- Сработает (nonce совпадает с CSP) -->
<script nonce="r4Nd0mBase64Token" src="/app.js"></script>

<!-- Не сработает в браузерах с strict-dynamic (nonce отсутствует) -->
<script src="/no-nonce.js"></script>
```


### Можно ли удалить политику через DevTools?
Ключевой момент: CSP защищает жертв, а не разработчика/админа в своём браузере. Чтобы “обойти CSP” у жертвы, злоумышленнику нужно заставить браузер жертвы загрузить страницу уже без CSP. А он не может открыть DevTools у пользователя и удалить политику.



## HTML/CSS 
### Подключение локального шрифта через css файл
```css
@font-face {
  font-family: "Inter";
  src: url("/assets/fonts/Inter-VariableFont.woff2") format("woff2");
  font-weight: 100 900;   /* диапазон, а не одно число */
  font-style: normal;
  font-display: swap;
}

body {
  font-family: "Inter", system-ui, sans-serif;
}

h1 { font-weight: 750; }  /* можно любые значения внутри 100..900 */
```

### autocomplete
[**autocomplete**](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Attributes/autocomplete) - это подсказка браузеру, как автозаполнять поле (из сохранённых данных, менеджера паролей и т.п.). 

Эта функция доступна для `<input>` элементов, которые принимают в качестве входных данных текстовое или числовое значение, а также для `<textarea>` элементов, `<select>` элементов и `<form>` элементов.
 
Для `input` типа `password` и типа `text` (для логина) в этом задании использовались значения атрибута `autocomplete`:
- `current-password`
  - браузер/менеджер паролей понимает, что это существующий пароль для текущего аккаунта;
  - может предложить автозаполнить сохранённый пароль;
  - корректно связывает поле с `autocomplete="username"` (если оно есть рядом), чтобы подставлять правильную пару логин+пароль.
- `new-password` - ставят на поле пароля при регистрации или смене пароля. Браузер понимает, что пароль нужно создать новый, поэтому может предложить сгенерировать его и сохранить, не подставляя старые сохранённые пароли
- `username` - ставят на поле логина/имени пользователя. Это помогает браузеру и менеджеру паролей правильно автозаполнять логин и связывать его с полем пароля (`current-password`/`new-password`) для корректной подстановки пары логин-пароль.


